(window.webpackJsonp=window.webpackJsonp||[]).push([[115],{432:function(e,a,r){"use strict";r.r(a);var s=r(39),t=Object(s.a)({},(function(){var e=this,a=e.$createElement,r=e._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("p",[e._v("这些天在写一些功能的时候，希望可以把一些方法改写为函数式调用的链式写法，但是这些操作很多是基于Promise的异步调用，后来发现可以基于rxjs的自定义pipe很好的解决这个问题 ，既可以保障函数调用足够简单，不产生回调地狱类似的问题，由可以很好的生成异步任务队列。")]),e._v(" "),r("p",[e._v("有这样一组任务:")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("任务A \n任务B\n任务C\n")])])]),e._v(" "),r("p",[e._v("任务A,B,C 之间是完全异步的，但是需要按顺序执行，这是当然可以用"),r("code",[e._v("await")]),e._v("来完成,但还有时需要数据在A,B,C之间进行传递,可能写成这样:")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("await 任务A(result)\nawait 任务B(result)\nawait 任务C(result)\n")])])]),r("p",[e._v("这是可以通过一个"),r("code",[e._v("result")]),e._v("对象来存储返回的结果，但是如果在某个任务失败的情况下来终止任务就需要添加"),r("code",[e._v("throw")]),e._v("操作，当然我希望可以写成这样:")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("x\n.任务A()\n.任务B()\n.任务C()\n\n")])])]),r("p",[e._v("但是在保障任务顺序执行和终止上需要还多额外的工作，后来想到了rxjs的pipe:")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("obserable.pipe(\n\t任务A(),\n    任务B()\n    任务C()\n)\n")])])]),r("p",[e._v("这样的调用方式刚好满足我的需要，下载只需要编写对应的自定义"),r("code",[e._v("pipe")]),e._v("即可。")]),e._v(" "),r("p",[e._v("自定应"),r("code",[e._v("pipe")]),e._v("需要返回一个函数"),r("code",[e._v("<T>(source: Observable<V>) => Observable<V>")])]),e._v(" "),r("p",[e._v("这个函数中传入的"),r("code",[e._v("Observable")]),e._v("用来传入"),r("code",[e._v("pipe")]),e._v("目标"),r("code",[e._v("observable")]),e._v("中的数据，返回的"),r("code",[e._v("Observable")]),e._v("用来控制pipe的状态,来控制pipe是否继续向下执行,如任务B发生异常是执行error方法，就会终止后续任务的执行，这样满足了我们在"),r("code",[e._v("pipe")]),e._v("进行异步操作的需求。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("public call(handler: (arg) => Promise<any>) {\n    return <T>(source: Observable<any>) =>\n      new Observable<any>(observer => {\n        return source.subscribe({\n          next: async (data) => {\n            handler(data)\n              .then(() => {\n                observer.next(tx)\n              })\n              .catch(err => {\n                observer.error(err)\n              })\n              .finally(() => loading.dismiss())\n          },\n          error(err) {\n            observer.error(err)\n          },\n          complete() {\n            observer.complete()\n          }\n        })\n      })\n  }\n")])])]),r("p",[e._v("传入的"),r("code",[e._v("handler")]),e._v("是一个promise操作，这样就可以把一个Promise方法封装到这个"),r("code",[e._v("pipe")]),e._v("中。")]),e._v(" "),r("p",[e._v("为了可以进行调用，我们需要在管道外加一层")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("  public transaction(result): Observable<Transaction> {\n    return Observable.create(observer => {\n      observer.next(result)\n    })\n  }\n")])])]),r("p",[r("code",[e._v("result")]),e._v("可以作为数据结果共享的载体，这样多个自定义"),r("code",[e._v("pipe")]),e._v("之间就通过"),r("code",[e._v("result")]),e._v("共享数据。")]),e._v(" "),r("p",[e._v("调用时就可以像这样方便的调用了:")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("transaction(result).pipe(\n      this.call(...promise操作A),\n      this.call(...promise操作B)\n    )\n")])])])])}),[],!1,null,null,null);a.default=t.exports}}]);