(window.webpackJsonp=window.webpackJsonp||[]).push([[123],{440:function(t,e,a){"use strict";a.r(e);var n=a(39),s=Object(n.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("在开发过程中遇到这样一个问题，"),a("code",[t._v("如何跨组件传递插槽")]),t._v("。因为在开发类似树组件的过程中，插槽需要通过外部传递到树的根节点，然后通过根节点依次传递到各个叶子节点。那么如何把根节点的"),a("code",[t._v("Slot")]),t._v("如传递给子组件呢?")]),t._v(" "),a("p",[t._v("我们在开发过程中，希望可以这样实现重新定义叶子节点的结构：")]),t._v(" "),a("div",{staticClass:"language-vue extra-class"},[a("pre",{pre:!0,attrs:{class:"language-vue"}},[a("code",[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("data-tree")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("template")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[a("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("v-slot:")]),t._v("node")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("data"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n    \t"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("div")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("{{data.title}} - {{data.text}}"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("div")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("template")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("data-tree")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])])]),a("p",[t._v("那么如何在组件内传递"),a("code",[t._v("Slot")]),t._v("就是一个问题。")]),t._v(" "),a("h4",{attrs:{id:"嵌套传递"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#嵌套传递"}},[t._v("#")]),t._v(" 嵌套传递")]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("通过固定级别的组件结构里可以通过直接书写"),a("code",[t._v("<v-slot ...>")]),t._v("来传递对应的"),a("code",[t._v("Slot")]),t._v("元素,来实现一层一层的传递。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<data-tree>\n\t<data-tree-item>\n      <template :node="data">\n            <slot :data="data"> xxx </slot>\n        </template>\n    </data-tree-item>\n</data-tree>\n')])])]),a("p",[t._v("通过在外层创建"),a("code",[t._v("slot")]),t._v("可以逐层将"),a("code",[t._v("slot")]),t._v("进行传递，但是如果过多的嵌套层次，这样就显得很麻烦。")]),t._v(" "),a("h4",{attrs:{id:"render"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#render"}},[t._v("#")]),t._v(" Render")]),t._v(" "),a("p",[t._v("还有一种方案是通过"),a("code",[t._v("Render")]),t._v("函数来进行显示，可以通过"),a("code",[t._v("$slots")]),t._v("来访问当前组件的"),a("code",[t._v("slot")]),t._v("元素，然后通过"),a("code",[t._v("Render")]),t._v("函数创建新组件时，将"),a("code",[t._v("slot")]),t._v("传递给下一层。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("h('data-tree-item',{\n\t scopedSlots: {\n      \tnode: props => this.$slots.node(props)\n    },\n})\n")])])]),a("p",[t._v("这样通过"),a("code",[t._v("Render")]),t._v("子元素就可以接受到对应的"),a("code",[t._v("Slot")]),t._v(",也实现了传递。")]),t._v(" "),a("h4",{attrs:{id:"动态组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#动态组件"}},[t._v("#")]),t._v(" 动态组件")]),t._v(" "),a("p",[t._v("还有一种方式是通过动态组件，也是认为比较推荐的实现方式，不是通过传递"),a("code",[t._v("Slot")]),t._v("，而是通过子节点主动去获取根节点的"),a("code",[t._v("Slot")]),t._v("对象，然后直接在UI中渲染出来。")]),t._v(" "),a("p",[t._v("为此我们需要创建一个组件来渲染对应的"),a("code",[t._v("Slot")]),t._v("对象。")]),t._v(" "),a("p",[t._v("首先需要获取根节点:")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const rootComponentName = 'data-tree'\n/**\n * 获取父组件\n */\nconst getRootComponent = (\n    component: ComponentInternalInstance | null\n): ComponentInternalInstance | undefined => {\n    if (component && component.type.name === rootComponentName) {\n        return component\n    }\n\n    if (component && component.parent) {\n        const parent = component.parent\n        return getRootComponent(parent)\n    }\n}\n")])])]),a("p",[t._v("通过递归我们可以获取到对应的父节点，这样我们就可以把"),a("code",[t._v("Slot")]),t._v("作为"),a("code",[t._v("Data")]),t._v("暴露出来")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("setup(props) {\n        // 获取根节点\n        const dataTree = getRootComponent(getCurrentInstance())\n        const parentSlots = dataTree?.slots\n        const nodeTemplate = parentSlots?.node as any\n        return {\n            nodeTemplate\n        }\n    } \n")])])]),a("p",[t._v("这时候我们需要一个组件来渲染暴露出来的"),a("code",[t._v("Slot")]),t._v(":")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("components: {\n        TemplateContainer: {\n            functional: true,\n            props: {\n                template: {\n                    type: Function\n                },\n                data: {\n                    type: Object\n                }\n            },\n            render: (props, ctx) => h('div', [props.template(props.data)])\n        }\n    }\n")])])]),a("p",[t._v("好了现在该准备的都准备好了，可以去实现UI的显示了：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(' <template-container\n                    v-if="nodeTemplate"\n                    :template="nodeTemplate"\n                    :data="node">\n</template-container>\n<template v-else>\n       {{ node.label }}\n</template>\n')])])]),a("p",[t._v("这样我们就实现了类似下面定义"),a("code",[t._v("Slot")]),t._v("的传递，也解决了我们跨组件传递"),a("code",[t._v("Slot")]),t._v("的问题。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<slot :data="node" name="node">\n\t {{ node.label }}\n</slot>\n')])])]),a("p",[t._v("本文使用的是"),a("code",[t._v("Vue 3")]),t._v("的事例，"),a("code",[t._v("Vue 2")]),t._v("也是相同的概念，在"),a("code",[t._v("Vue 3")]),t._v("中除了使用"),a("code",[t._v("getRootComponent")]),t._v("来查询跟节点,也可以使用"),a("code",[t._v("Provide/Inject")]),t._v("来将"),a("code",[t._v("Slot")]),t._v("主动传递给子节点。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("            `\n")])])])])}),[],!1,null,null,null);e.default=s.exports}}]);