(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{378:function(e,n,t){"use strict";t.r(n);var a=t(39),r=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("在之前说过的如：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("fillOrderERC20\nfillOrderFees\nfillOrderERC721\n")])])]),t("p",[e._v("的例子中,都是由taker进行最后的交易确认，所以taker都是最后的交易执行者，他负责支付执行合约需要的费用(ETH)。")]),e._v(" "),t("p",[e._v("在"),t("code",[e._v("executeTransaction")]),e._v("的例子中还有一个类似委托的模式来执行交易，就是maker来生成订单，然后进行签名。taker同样对这个订单进行签名，然后交给sender进行执行。sender是最后交易的执行者，支付执行合约的费用。")]),e._v(" "),t("p",[e._v("这个模式下，maker只需要提供对应的订单信息，由taker签名后交给sender即可。")]),e._v(" "),t("p",[e._v("当然maker如果在真正的执行交易前不想进行交易，可以通过"),t("code",[e._v("transactionEncoder.cancelOrderTx")]),e._v("来取消这个订单。这是该订单即无法进行交易。")]),e._v(" "),t("p",[t("code",[e._v("transactionEncoder")]),e._v("主要的功能应该就是引入第三方来促成交易。")]),e._v(" "),t("p",[e._v("相关源码:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("   PrintUtils.printScenario('Execute Transaction fillOrder');\n   // Initialize the ContractWrappers, this provides helper functions around calling\n   // 0x contracts as well as ERC20/ERC721 token contracts on the blockchain\n   const contractWrappers = new ContractWrappers(providerEngine, { networkId: NETWORK_CONFIGS.networkId });\n   // Initialize the Web3Wrapper, this provides helper functions around fetching\n   // account information, balances, general contract logs\n   const web3Wrapper = new Web3Wrapper(providerEngine);\n   // 获取maker,taker,sender地址\n   const [maker, taker, sender] = await web3Wrapper.getAvailableAddressesAsync();\n   const feeRecipientAddress = sender;\n   const zrxTokenAddress = contractAddresses.zrxToken;\n   const etherTokenAddress = contractAddresses.etherToken;\n   const printUtils = new PrintUtils(\n       web3Wrapper,\n       contractWrappers,\n       { maker, taker, sender },\n       { WETH: etherTokenAddress, ZRX: zrxTokenAddress },\n   );\n   printUtils.printAccounts();\n\n   // 设置交易金额以及交易费用\n   // the amount the maker is selling of maker asset\n   const makerAssetAmount = Web3Wrapper.toBaseUnitAmount(new BigNumber(5), DECIMALS);\n   // the amount the maker wants of taker asset\n   const takerAssetAmount = Web3Wrapper.toBaseUnitAmount(new BigNumber(0.1), DECIMALS);\n   // the amount of fees the maker pays in ZRX\n   const makerFee = Web3Wrapper.toBaseUnitAmount(new BigNumber(0.01), DECIMALS);\n   // the amount of fees the taker pays in ZRX\n   const takerFee = Web3Wrapper.toBaseUnitAmount(new BigNumber(0.01), DECIMALS);\n   // 0x v2 uses hex encoded asset data strings to encode all the information needed to identify an asset\n   // 设置交易币种\n   const makerAssetData = assetDataUtils.encodeERC20AssetData(zrxTokenAddress);\n   const takerAssetData = assetDataUtils.encodeERC20AssetData(etherTokenAddress);\n   let txHash;\n\n   // 对代币账户进行授权\n   // Approve the ERC20 Proxy to move ZRX for maker\n   const makerZRXApprovalTxHash = await contractWrappers.erc20Token.setUnlimitedProxyAllowanceAsync(\n       zrxTokenAddress,\n       maker,\n   );\n   await printUtils.awaitTransactionMinedSpinnerAsync('Maker ZRX Approval', makerZRXApprovalTxHash);\n\n   // Approve the ERC20 Proxy to move ZRX for taker\n   const takerZRXApprovalTxHash = await contractWrappers.erc20Token.setUnlimitedProxyAllowanceAsync(\n       zrxTokenAddress,\n       taker,\n   );\n   await printUtils.awaitTransactionMinedSpinnerAsync('Taker ZRX Approval', takerZRXApprovalTxHash);\n\n   // Approve the ERC20 Proxy to move WETH for taker\n   const takerWETHApprovalTxHash = await contractWrappers.erc20Token.setUnlimitedProxyAllowanceAsync(\n       etherTokenAddress,\n       taker,\n   );\n   await printUtils.awaitTransactionMinedSpinnerAsync('Taker WETH Approval', takerWETHApprovalTxHash);\n\n   // Convert ETH into WETH for taker by depositing ETH into the WETH contract\n   const takerWETHDepositTxHash = await contractWrappers.etherToken.depositAsync(\n       etherTokenAddress,\n       takerAssetAmount,\n       taker,\n   );\n   await printUtils.awaitTransactionMinedSpinnerAsync('Taker WETH Deposit', takerWETHDepositTxHash);\n\n   PrintUtils.printData('Setup', [\n       ['Maker ZRX Approval', makerZRXApprovalTxHash],\n       ['Taker ZRX Approval', takerZRXApprovalTxHash],\n       ['Taker WETH Approval', takerWETHApprovalTxHash],\n       ['Taker WETH Deposit', takerWETHDepositTxHash],\n   ]);\n\n   // Set up the Order and fill it\n   // 获取过期时间\n   const randomExpiration = getRandomFutureDateInSeconds();\n\n   // 生成未签名订单\n   // Create the order\n   const orderWithoutExchangeAddress = {\n       makerAddress: maker,\n       takerAddress: NULL_ADDRESS,\n       senderAddress: NULL_ADDRESS,\n       feeRecipientAddress,\n       expirationTimeSeconds: randomExpiration,\n       salt: generatePseudoRandomSalt(),\n       makerAssetAmount,\n       takerAssetAmount,\n       makerAssetData,\n       takerAssetData,\n       makerFee,\n       takerFee,\n   };\n\n   // 设置交易地址-0x地址\n   const exchangeAddress = contractAddresses.exchange;\n   const order: Order = {\n       ...orderWithoutExchangeAddress,\n       exchangeAddress,\n   };\n   printUtils.printOrder(order);\n\n   // Print out the Balances and Allowances\n   await printUtils.fetchAndPrintContractAllowancesAsync();\n   await printUtils.fetchAndPrintContractBalancesAsync();\n\n   // maer对订单进行签名\n   // Generate the order hash and sign it\n   const orderHashHex = orderHashUtils.getOrderHashHex(order);\n   const signature = await signatureUtils.ecSignHashAsync(providerEngine, orderHashHex, maker);\n\n   const signedOrder: SignedOrder = {\n       ...order,\n       signature,\n   };\n\n   // 执行交易\n   // The transaction encoder provides helpers in encoding 0x Exchange transactions to allow\n   // a third party to submit the transaction. This operates in the context of the signer (taker)\n   // rather then the context of the submitter (sender)\n   // transactionEncoder包装交易信息\n   const transactionEncoder = await contractWrappers.exchange.transactionEncoderAsync();\n   // This is an ABI encoded function call that the taker wishes to perform\n   // in this scenario it is a fillOrder\n   // 如果希望取消交易那么使用cancelOrderTx即可\n   // const cancelData = transactionEncoder.cancelOrderTx(signedOrder);\n   const fillData = transactionEncoder.fillOrderTx(signedOrder, takerAssetAmount);\n   // Generate a random salt to mitigate replay attacks\n   const takerTransactionSalt = generatePseudoRandomSalt();\n   // The taker signs the operation data (fillOrder) with the salt\n   // taker对交易进行签名\n   // 如果是要取消交易的话，签名应该由maker进行签名\n   const executeTransactionHex = transactionEncoder.getTransactionHashHex(fillData, takerTransactionSalt, taker);\n   const takerSignatureHex = await signatureUtils.ecSignHashAsync(providerEngine, executeTransactionHex, taker);\n   // The sender submits this operation via executeTransaction passing in the signature from the taker\n   // sender使用taker提供的签名执行交易\n   txHash = await contractWrappers.exchange.executeTransactionAsync(\n       takerTransactionSalt,\n       taker,\n       fillData,\n       takerSignatureHex,\n       sender,\n       {\n           gasLimit: TX_DEFAULTS.gas,\n       },\n   );\n   const txReceipt = await printUtils.awaitTransactionMinedSpinnerAsync('executeTransaction', txHash);\n   printUtils.printTransaction('Execute Transaction fillOrder', txReceipt, [['orderHash', orderHashHex]]);\n\n   // Print the Balances\n   await printUtils.fetchAndPrintContractBalancesAsync();\n\n   // Stop the Provider Engine\n   providerEngine.stop();\n")])])])])}),[],!1,null,null,null);n.default=r.exports}}]);