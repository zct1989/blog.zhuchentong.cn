(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{382:function(e,n,t){"use strict";t.r(n);var r=t(39),a=Object(r.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("还有一种场景的叫做"),t("code",[e._v("dutchAuction")]),e._v(",翻译时荷兰式拍卖，也就是减价拍卖，由卖家给出开始拍卖的价格以及最低价格，随着时间价格会一路走低，一直到最低拍卖价。\n在0x中这种交易其实也是由"),t("code",[e._v("match order")]),e._v("的方式完成，不过实时价格由拍卖合约确定")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const auctionDetails = await contractWrappers.dutchAuction.getAuctionDetailsAsync(sellSignedOrder);\nconst currentAuctionAmount = auctionDetails.currentAmount;\n")])])]),t("p",[e._v("卖家通过确定拍卖资产，拍卖金额，拍卖开始时间，通过"),t("code",[e._v("dutchAuctionWrapper.encodeDutchAuctionAssetData")]),e._v("将数据打包为拍卖资产，将拍卖资产的订单签名发布。之后由买方通过"),t("code",[e._v("contractWrappers.dutchAuction")]),e._v("获取实时拍卖价格，创建买方订单并进行签名，通过"),t("code",[e._v("match order")]),e._v("完成订单交易。")]),e._v(" "),t("p",[e._v("具体场景源码如下:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("PrintUtils.printScenario('Dutch Auction');\n    // Initialize the ContractWrappers, this provides helper functions around calling\n    // 0x contracts as well as ERC20/ERC721 token contracts on the blockchain\n    const contractWrappers = new ContractWrappers(providerEngine, { networkId: NETWORK_CONFIGS.networkId });\n    // Initialize the Web3Wrapper, this provides helper functions around fetching\n    // account information, balances, general contract logs\n    const web3Wrapper = new Web3Wrapper(providerEngine);\n    // 获得卖方，买方地址\n    const [sellMaker, buyMaker] = await web3Wrapper.getAvailableAddressesAsync();\n    const zrxTokenAddress = contractAddresses.zrxToken;\n    const etherTokenAddress = contractAddresses.etherToken;\n    const printUtils = new PrintUtils(\n        web3Wrapper,\n        contractWrappers,\n        { sellMaker, buyMaker },\n        { WETH: etherTokenAddress, ZRX: zrxTokenAddress },\n    );\n    printUtils.printAccounts();\n\n    // the amount the maker is selling of maker asset\n    const makerAssetAmount = Web3Wrapper.toBaseUnitAmount(new BigNumber(10), DECIMALS);\n    // the initial opening price of the auction\n    // 拍卖初始金额\n    const auctionBeginAmount = Web3Wrapper.toBaseUnitAmount(new BigNumber(1), DECIMALS);\n    // the final amount at the end of the auction\n    // 拍卖下限金额\n    const auctionEndAmount = Web3Wrapper.toBaseUnitAmount(new BigNumber(0.1), DECIMALS);\n    // 0x v2 uses hex encoded asset data strings to encode all the information needed to identify an asset\n    // 设置交易资产\n    const makerAssetData = assetDataUtils.encodeERC20AssetData(zrxTokenAddress);\n    const takerAssetData = assetDataUtils.encodeERC20AssetData(etherTokenAddress);\n    // Begin the auction ten minutes ago\n    // 10分钟前秒数\n    const auctionBeginTimeSeconds = new BigNumber(Date.now() - TEN_MINUTES_MS)\n        .div(ONE_SECOND_MS)\n        .integerValue(BigNumber.ROUND_CEIL);\n    // Additional data is encoded in the maker asset data, this includes the begin time and begin amount\n    // for the auction\n    // 生成拍卖数据，资产类型，开始拍卖时间，开始拍卖金额\n    const dutchAuctionEncodedAssetData = DutchAuctionWrapper.encodeDutchAuctionAssetData(\n        makerAssetData,\n        auctionBeginTimeSeconds,\n        auctionBeginAmount,\n    );\n    let txHash;\n    let txReceipt;\n\n    // Allow the 0x ERC20 Proxy to move ZRX on behalf of makerAccount\n    // 对0x进行资产授权\n    const sellMakerZRXApprovalTxHash = await contractWrappers.erc20Token.setUnlimitedProxyAllowanceAsync(\n        zrxTokenAddress,\n        sellMaker,\n    );\n    await printUtils.awaitTransactionMinedSpinnerAsync('Sell Maker ZRX Approval', sellMakerZRXApprovalTxHash);\n\n    // Approve the ERC20 Proxy to move WETH for rightMaker\n    const buyMakerWETHApprovalTxHash = await contractWrappers.erc20Token.setUnlimitedProxyAllowanceAsync(\n        etherTokenAddress,\n        buyMaker,\n    );\n    await printUtils.awaitTransactionMinedSpinnerAsync('Buy Maker WETH Approval', buyMakerWETHApprovalTxHash);\n\n    // Convert ETH into WETH for taker by depositing ETH into the WETH contract\n    const buyMakerWETHDepositTxHash = await contractWrappers.etherToken.depositAsync(\n        etherTokenAddress,\n        auctionBeginAmount,\n        buyMaker,\n    );\n    await printUtils.awaitTransactionMinedSpinnerAsync('Buy Maker WETH Deposit', buyMakerWETHDepositTxHash);\n\n    PrintUtils.printData('Setup', [\n        ['Sell Maker ZRX Approval', sellMakerZRXApprovalTxHash],\n        ['Buy Maker WETH Approval', buyMakerWETHApprovalTxHash],\n        ['Buy Maker WETH Deposit', buyMakerWETHDepositTxHash],\n    ]);\n\n    // Set up the Order and fill it\n    // 生成订单过期时间\n    // 生成交易地址\n    const randomExpiration = getRandomFutureDateInSeconds();\n    const exchangeAddress = contractAddresses.exchange;\n\n    // Create the order\n    // 创建买方订单\n    const sellOrder: Order = {\n        exchangeAddress,\n        makerAddress: sellMaker,\n        // taker address is specified to ensure ONLY the dutch auction contract\n        // can fill this order (ensuring the price given the block time)\n        // taker地址为拍卖合约地址\n        takerAddress: contractWrappers.dutchAuction.address,\n        senderAddress: NULL_ADDRESS,\n        feeRecipientAddress: NULL_ADDRESS,\n        expirationTimeSeconds: randomExpiration,\n        salt: generatePseudoRandomSalt(),\n        makerAssetAmount,\n        // taker asset amount is the auction end price. The Dutch Auction\n        // contract ensures this is filled at the correct amount\n        // taker资产金额为拍卖下限金额\n        takerAssetAmount: auctionEndAmount,\n        // maker asset data is encoded with additional data used by\n        // the Dutch Auction contract\n        // 卖方资产为包含拍卖信息\n        makerAssetData: dutchAuctionEncodedAssetData,\n        takerAssetData,\n        makerFee: ZERO,\n        takerFee: ZERO,\n    };\n    PrintUtils.printData('Sell Order', Object.entries(sellOrder));\n    // Generate the order hash and sign it\n    // 对订单进行签名\n    const sellOrderHashHex = orderHashUtils.getOrderHashHex(sellOrder);\n    const sellOrderSignature = await signatureUtils.ecSignHashAsync(providerEngine, sellOrderHashHex, sellMaker);\n    const sellSignedOrder = { ...sellOrder, signature: sellOrderSignature };\n\n    // Create the buy order\n    // 因为价格随时间变化，通过getAuctionDetailsAsyn获取当前的价格信息\n    const auctionDetails = await contractWrappers.dutchAuction.getAuctionDetailsAsync(sellSignedOrder);\n    const currentAuctionAmount = auctionDetails.currentAmount;\n    // The buyer creates a matching order, specifying the current auction amount\n    // 创建买方订单\n    const buyOrder: Order = {\n        ...sellOrder,\n        makerAddress: buyMaker,\n        makerAssetData: sellOrder.takerAssetData,\n        takerAssetData: sellOrder.makerAssetData,\n        makerAssetAmount: currentAuctionAmount,\n        takerAssetAmount: sellOrder.makerAssetAmount,\n    };\n    PrintUtils.printData('Buy Order', Object.entries(buyOrder));\n\n    // Generate the order hash and sign it\n    // 签名买方订单\n    const buyOrderHashHex = orderHashUtils.getOrderHashHex(buyOrder);\n    const buyOrderSignature = await signatureUtils.ecSignHashAsync(providerEngine, buyOrderHashHex, buyMaker);\n    const buySignedOrder = { ...buyOrder, signature: buyOrderSignature };\n\n    // Print out the Balances and Allowances\n    await printUtils.fetchAndPrintContractAllowancesAsync();\n    await printUtils.fetchAndPrintContractBalancesAsync();\n    // Match the orders via the Dutch Auction contract\n    // 通过匹配订单完成交易\n    txHash = await contractWrappers.dutchAuction.matchOrdersAsync(buySignedOrder, sellSignedOrder, buyMaker, {\n        gasLimit: TX_DEFAULTS.gas,\n    });\n\n    txReceipt = await printUtils.awaitTransactionMinedSpinnerAsync('DutchAuction', txHash);\n    printUtils.printTransaction('DutchAuction', txReceipt, [\n        ['sell orderHash', sellOrderHashHex],\n        ['buy orderHash', buyOrderHashHex],\n    ]);\n\n    // Print the Balances\n    await printUtils.fetchAndPrintContractBalancesAsync();\n\n    // Stop the Provider Engine\n    providerEngine.stop();\n")])])])])}),[],!1,null,null,null);n.default=a.exports}}]);