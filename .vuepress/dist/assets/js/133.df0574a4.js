(window.webpackJsonp=window.webpackJsonp||[]).push([[133],{450:function(a,r,v){"use strict";v.r(r);var t=v(39),_=Object(t.a)({},(function(){var a=this,r=a.$createElement,v=a._self._c||r;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("p",[a._v("几乎所有的编程语言最基本的功能都是变量的存储和访问，正是这种变量的存储和访问的能力将状态带给了程序，而作用域的就是为了寻找和访问变量设计的一套规则。")]),a._v(" "),v("h2",{attrs:{id:"理解作用域"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#理解作用域"}},[a._v("#")]),a._v(" 理解作用域")]),a._v(" "),v("p",[a._v("在理解作用域前我们先来看一下程序的编译原理，大多数的程序的编译原理大概三个步骤：")]),a._v(" "),v("h4",{attrs:{id:"分词-词法分析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分词-词法分析"}},[a._v("#")]),a._v(" 分词/词法分析")]),a._v(" "),v("p",[a._v("这个过程会将有字符串组成的代码块，分解成一个一个的词法单元。例如var a = 2 ;会被分解为var,a,=,2,;")]),a._v(" "),v("h4",{attrs:{id:"解析-语法分析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#解析-语法分析"}},[a._v("#")]),a._v(" 解析/语法分析")]),a._v(" "),v("p",[a._v("这个过程会将分解的词法单元进行组合，组成一个抽象语法树林(AST,Abstract Syntax Tree)")]),a._v(" "),v("h4",{attrs:{id:"代码生成"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#代码生成"}},[a._v("#")]),a._v(" 代码生成")]),a._v(" "),v("p",[a._v("会将抽象语法树转换成转为可以执行的代码，转为一组机器指令进行执行\n有了上面的编译原理，我们就可以看看如何把var a = 2;这段代码如何在机器中进行解释")]),a._v(" "),v("p",[a._v("var a =2;在分词后重组为AST,语言编辑执行分为两步")]),a._v(" "),v("ol",[v("li",[a._v("var a编译器询问作用域中的a变量，如果存在则返回变量地址，如果不存在则创建一个a变量")]),a._v(" "),v("li",[a._v("a =2，在当前作用与中查询a变量，如果存在则返回变量地址，否则则创建一个，将数值2存储到变量a对应的地址中。")])]),a._v(" "),v("h2",{attrs:{id:"lsh-和-rsh"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#lsh-和-rsh"}},[a._v("#")]),a._v(" LSH 和 RSH")]),a._v(" "),v("p",[a._v("上面我们大概说了程序会如何配合作用域处理var a = 2;代码，下来我们来看看查询时所用的两种查询:")]),a._v(" "),v("ul",[v("li",[a._v("LSH")]),a._v(" "),v("li",[a._v("RSH")])]),a._v(" "),v("p",[a._v("LSH查询是指目标地址查询，它一般出现在赋值运算符的左侧，它用来查询变量的存储地址；RSH查询是指源值查询，它一般出现在赋值运算符的右侧，它用来获取变量的源值")]),a._v(" "),v("p",[a._v("下面我们看一个例子：")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("function foo(a){\n    console.log(a)\n}\nfoo(2)\n")])])]),v("p",[a._v("我们分析一下上面所有到的查询:")]),a._v(" "),v("ol",[v("li",[a._v("对foo对象使用RSH查询，获取foo函数的值\n对隐式a=2中的a使用LSH查询，在当前作用域中请求变量a地址，不存在则创建")]),a._v(" "),v("li",[a._v("对console对象使用RSH查询，获取console对象值")]),a._v(" "),v("li",[a._v("对变量a使用RSH查询获取值并传递给console.log函数")])]),a._v(" "),v("h2",{attrs:{id:"作用域链"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#作用域链"}},[a._v("#")]),a._v(" 作用域链")]),a._v(" "),v("p",[a._v("我们通过之前的一些例子理解作用域，可以每次进行查询时，都会向当前作用域进行LHS和RHS请求，可以把当前作用域想想成一个变量数组，如果当前作用域的变量数组中不存在该变量，那么它会想上级作用域请求，在上级的作用域中进行查询，有则返回，没有则依次向上，这种作用域模型成为作用域链，可以把它理解成一个树的数据模型，有唯一一个根节点，是根作用域，代码在当前执行作用域节点进行请求，如果找到则返回，如果没有则依次向上，直到请求到根节点，这时可以你找到可你的变量，也可能没有找到，无论如何查找过程都将停止。")]),a._v(" "),v("p",[a._v("连接嵌套的作用域，形成了作用域链，完成了变量查找和存储的规则。")]),a._v(" "),v("h2",{attrs:{id:"异常"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#异常"}},[a._v("#")]),a._v(" 异常")]),a._v(" "),v("p",[a._v("在执行"),v("code",[a._v("LHS")]),a._v("和"),v("code",[a._v("RHS")]),a._v("的过程中主要有两种异常：")]),a._v(" "),v("ul",[v("li",[a._v("RenferenceError")]),a._v(" "),v("li",[a._v("TypeError")])]),a._v(" "),v("p",[a._v("RenferenceError异常主要是出现在RHS查询过程中没有在可查找的作用域中找到相应的变量，在严格模式中LHS也会触发RenferenceError异常\nTypeError则是如果查询成功，但是对该对象执行不合理的操作或引用空类型值中的属性时，引擎会抛出该异常。\nReferenceError表示作用域内查询失败，而TypeError则表示作用域内判别成功。")])])}),[],!1,null,null,null);r.default=_.exports}}]);