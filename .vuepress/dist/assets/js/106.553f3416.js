(window.webpackJsonp=window.webpackJsonp||[]).push([[106],{423:function(n,e,r){"use strict";r.r(e);var t=r(39),s=Object(t.a)({},(function(){var n=this,e=n.$createElement,r=n._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[r("p",[r("code",[n._v("Ownable.sol")]),n._v("合约的作用是实现对合约所有权的控制,通过确定合约所有权，\b 来对合约函数执行 \b 权限进行控制，合约的所有权只能属于单一地址。同时支持转移以及放弃合约所有权。合约所有权默认属于部署合约的账户。")]),n._v(" "),r("h5",{attrs:{id:"事件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#事件"}},[n._v("#")]),n._v(" 事件")]),n._v(" "),r("hr"),n._v(" "),r("ul",[r("li",[n._v("合约所有权转移事件")])]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("event OwnershipTransferred(\n  address indexed previousOwner,\n  address indexed newOwner\n);\n")])])]),n._v(" "),r("h5",{attrs:{id:"装饰器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#装饰器"}},[n._v("#")]),n._v(" \b 装饰器")]),n._v(" "),r("hr"),n._v(" "),r("ul",[r("li",[n._v("\b\b 仅限合约所有者执行")])]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("modifier onlyOwner() {\n  require(isOwner());\n  _;\n}\n")])])]),r("h5",{attrs:{id:"方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#方法"}},[n._v("#")]),n._v(" 方法")]),n._v(" "),r("hr"),n._v(" "),r("ul",[r("li",[n._v("返回合约拥有者地址")])]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("function owner() public view returns(address)\n")])])]),r("ul",[r("li",[n._v("返回合约调用地址是否是合约拥有者")])]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("function isOwner() public view returns(bool)\n")])])]),r("ul",[r("li",[n._v("放弃合约所有权(合约不属于任何地址)")])]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("function renounceOwnership() public onlyOwner\n")])])]),r("ul",[r("li",[n._v("转移合约所有权")])]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("function transferOwnership(address newOwner) public onlyOwner\n")])])]),r("h5",{attrs:{id:"合约代码"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#合约代码"}},[n._v("#")]),n._v(" 合约代码")]),n._v(" "),r("hr"),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v('pragma solidity ^0.4.24;\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of "user permissions".\n * @dev Ownable合约拥有一个owner字段,提供一个基础的权限控制功能，\n */\ncontract Ownable {\n  // 合约的拥有者,一般是合约的部署账户\n  address private _owner;\n\n  // 转移合约拥有者事件,当合约的拥有者转移是发送\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   * @dev Ownable合约的构造函数,这个函数去设置合约拥有者为合约的部署账户(调用构造函数的账户),address(0)为空地址\n   */\n  constructor() internal {\n    _owner = msg.sender;\n    emit OwnershipTransferred(address(0), _owner);\n  }\n\n  /**\n   * @return the address of the owner.\n   * @return 返回合约的拥有者\n   */\n  function owner() public view returns(address) {\n    return _owner;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   * @dev onlyOwner修饰器,保证函数的执行者是合约拥有者\n   */\n  modifier onlyOwner() {\n    require(isOwner());\n    _;\n  }\n\n  /**\n   * @return true if `msg.sender` is the owner of the contract.\n   * @return 返回当前合约调用者是否是合约的拥有者\n   */\n  function isOwner() public view returns(bool) {\n    return msg.sender == _owner;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   * @notice Renouncing to ownership will leave the contract without an owner.\n   * It will not be possible to call the functions with the `onlyOwner`\n   * modifier anymore.\n   * @dev 当前合约拥有者放弃合约所有权\n   * @notice 注意的是放弃合约的所有权，意味着这个合约不再存在拥有者,这回导致这个合约的\n   * 拥有`onlyOwner`修饰器的函数无法再被调用\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipTransferred(_owner, address(0));\n    _owner = address(0);\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   * @dev 当前合约拥有者将合约的所有权转移给其他账户\n   * @param newOwner 接收合约所有权的账户\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    _transferOwnership(newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   * @dev 当前合约拥有者将合约的所有权转移给其他账户(内部方法),目标账户不能是空地址(等于放弃合约所有权)\n   * @param newOwner 接收合约所有权的账户\n   */\n  function _transferOwnership(address newOwner) internal {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(_owner, newOwner);\n    _owner = newOwner;\n  }\n}\n\n')])])])])}),[],!1,null,null,null);e.default=s.exports}}]);